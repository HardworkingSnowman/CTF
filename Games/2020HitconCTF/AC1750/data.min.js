! function(t) {
    t.su.Proxy = function(e) {
        var r = t.extend({
            xtype: "proxy",
            url: null,
            async: !0,
            timeout: 15e3,
            reader: {
                url: null,
                root: "data",
                type: null,
                timeout: null
            },
            writer: {
                url: null,
                root: "data",
                type: null,
                timeout: null
            },
            type: "POST",
            dataType: "json",
            eventId: null,
            encrypt: !0
        }, e);
        r.reader.url = r.reader.url || r.url, r.reader.type = r.reader.type || r.type, r.reader.timeout = r.reader.timeout || r.timeout, r.reader.type = r.reader.type.toUpperCase(), r.writer.url = r.writer.url || r.url, r.writer.type = r.writer.type || r.type, r.writer.timeout = r.writer.timeout || r.timeout, r.writer.type = r.writer.type.toUpperCase(), t.extend(this, r), this.isProxy = !0
    }, t.su.Proxy.prototype.read = function(e, r, a, n, o, i) {
        e = t.extend({
            operation: "read"
        }, e);
        var s = i || this;
        return s.encrypt && (e = t.su.encryptor.dataEncrypt(t.param(e, !0), s.isLogin)), t.ajax({
            url: s.reader.url,
            type: s.reader.type,
            timeout: s.reader.timeout,
            dataType: s.dataType,
            async: s.async,
            cache: !1,
            data: e,
            traditional: !0,
            success: function(e, n, d) {
                if (s.encrypt) {
                    if ("" == e || e && "string" != typeof e.data) return;
                    try {
                        e = JSON.parse(t.su.encryptor.dataDecrypt(e.data))
                    } catch (u) {
                        t.encrypt.encryptManager.cleanStorage(), location.href = "/"
                    }
                }
                e.success ? s.callbackSuccess(e, r, o, "read", n, d, i) : s.callbackFail(e, a, o, "read", n, d, i), s.eventId && t.su.app.runningModule.fire(s.eventId)
            },
            error: function(e, r, a) {
                s.callbackError(n, o, "read", i, e, r, a), s.eventId && t.su.app.runningModule.fire(s.eventId)
            }
        })
    }, t.su.Proxy.prototype.write = function(e, r, a, n, o, i) {
        e = t.extend({
            operation: "write"
        }, e);
        var s = i || this;
        return s.encrypt && (e = t.su.encryptor.dataEncrypt(t.param(e, !0), s.isLogin)), t.ajax({
            url: s.writer.url,
            type: s.writer.type,
            timeout: s.writer.timeout,
            dataType: s.dataType,
            cache: !1,
            async: s.async,
            data: e,
            traditional: !0,
            success: function(e, n, d) {
                if (s.encrypt) {
                    if ("" == e || e && e.data == undefined) return;
                    try {
                        e = JSON.parse(t.su.encryptor.dataDecrypt(e.data))
                    } catch (u) {
                        t.encrypt.encryptManager.cleanStorage(), location.href = "/"
                    }
                }
                e.success ? s.callbackSuccess(e, r, o, "write", n, d, i) : s.callbackFail(e, a, o, "write", n, d, i), s.eventId && t.su.app.runningModule.fire(s.eventId)
            },
            error: function(e, r, a) {
                s.callbackError(n, o, "write", i, e, r, a), s.eventId && t.su.app.runningModule.fire(s.eventId)
            }
        })
    }, t.su.Proxy.prototype.callbackSuccess = function(e, r, a, n, o, i, s) {
        var d = s || this,
            u = (r = r || function() {}, a = !1 !== a, "read" == n ? d.reader.root : d.writer.root),
            l = "ev_" + n,
            p = null;
        p = u ? e[u] : e, r.call(d, p, e.others, o, i), a && t(d).trigger(l, [p, e.others, o, i])
    }, t.su.Proxy.prototype.callbackFail = function(e, r, a, n, o, i, s) {
        var d = s || this;
        r = r || function() {};
        switch (e.errorcode) {
            case "timeout":
                t.encrypt.encryptManager.cleanStorage(), location.href = "/";
                break;
            case "user conflict":
                t.su.app && t.su.app.errorOperation && t.su.app.errorOperation.userConflict && t.su.app.errorOperation.userConflict();
                break;
            case "permission denied":
                t.su.app && t.su.app.errorOperation && t.su.app.errorOperation.denied && t.su.app.errorOperation.denied()
        }
        r.call(d, e.errorcode, e.others, e.data), t(d).trigger("ev_failed", [e.errorcode, e.others, e.data])
    }, t.su.Proxy.prototype.callbackError = function(e, r, a, n, o, i, s) {
        var d = n || this,
            u = (e = e || function() {}, "read" == a ? d.reader.url : d.writer.url);
        d.preventErrorDefault, "read" == a ? e.call(d, o, i, s, u) : e.call(d, o, i, s), t(d).trigger("ev_error", [o, i, s, u])
    }
}(jQuery),
function(t) {
    t.su.Store = function(e) {
        var r = {
                updateMode: e.updateMode || "operation",
                insertMode: e.insertMode || e.updateMode || "operation",
                removeMode: e.removeMode || e.updateMode || "operation"
            },
            a = t.extend({}, {
                fields: null,
                xtype: "store",
                proxy: null,
                autoLoad: !1,
                tag: "store",
                global: !1,
                keyProperty: "key",
                updateMode: "operation",
                insertMode: "operation",
                removeMode: "operation",
                keyLength: 0
            }, e, r);
        return a.proxy ? !0 !== a.proxy.isProxy && (a.proxy = new t.su.Proxy(a.proxy)) : a.autoLoad = !1, a.fields && 0 !== a.fields.length && (1 != a.global || a.id) ? (this.id = a.id || t.su.randomId("store"), void this.init(a)) : null
    }, t.su.Store.prototype.init = function(e) {
        t.extend(this, e), this.data = [], this.snapshot = null, this.isStore = !0, this.isSorted = !1, !0 === this.autoLoad && this.load(), t(this).on("ev_datachanged", function(t, e, r) {
            this.isSorted = !1
        }), t.su.storeManager.add(this)
    }, t.su.Store.prototype.getData = function(t) {
        var e = this.data;
        this.keyProperty;
        if (!t) return undefined;
        var r = this.getIndex(t);
        return r == undefined ? undefined : e[r]
    }, t.su.Store.prototype.getDataByIndex = function(t) {
        return this.data[t]
    }, t.su.Store.prototype.getIndex = function(t) {
        var e = this.data,
            r = this.keyProperty;
        if (t == undefined) return undefined;
        for (var a = 0, n = e.length; a < n; a++)
            if (e[a][r].toString() == t.toString()) return a;
        return undefined
    }, t.su.Store.prototype.getKeyByIndex = function(t) {
        var e = this.data,
            r = this.keyProperty;
        return e[t][r]
    }, t.su.Store.prototype.getIndexs = function(t) {
        var e = this.data,
            r = this.keyProperty;
        if (0 == t.length) return undefined;
        for (var a = [], n = 0, o = t.length; n < o; n++)
            for (var i = 0, s = e.length; i < s; i++) {
                var d = t[n];
                if (e[i][r].toString() == d.toString()) {
                    a.push(i);
                    break
                }
            }
        return a
    }, t.su.Store.prototype.insert = function(e, r, a, n, o) {
        e = e == undefined || null == e ? r.length - 1 : e;
        var i = this,
            s = {};
        s[this.keyProperty] = "add", this.proxy.write(t.extend(s, {
            operation: "insert",
            index: e
        }, r), function(r, n, o, s) {
            t.isArray(r) || (r = [r]), r = i.dataFormat(r), "operation" == i.insertMode ? i.insertData(e, r, function(t, e) {
                a && a.call(i, t, e)
            }) : "complete" == i.insertMode ? i.loadData(r, n, !1, function(t) {
                a && a.call(i, t, n, o, s)
            }) : i.load({}, function(t, e, r, n) {
                a && a.call(i, t, e, r, n)
            })
        }, function(e, r) {
            n && n.call(i, e, r), t(i).trigger("ev_failed", ["insert", e, r])
        }, function(e, r, a) {
            o && o.call(i, e, r, a), t(i).trigger("ev_error", ["insert", e, r, a])
        })
    }, t.su.Store.prototype.load = function(e, r, a, n) {
        var o = this;
        e = e || {};
        this.proxy.read(t.extend({
            operation: "load"
        }, e), function(e, a, n, i) {
            e = o.dataFormat(e), o.loadData(e, a, !1, function(t) {
                r && r.call(o, t, a, n, i)
            }), t(o).trigger("ev_load", [o, e])
        }, function(e, r) {
            a && a.call(o, e, r), t(o).trigger("ev_failed", ["load", e, r])
        }, function(e, r, a) {
            n && n.call(o, e, r, a), t(o).trigger("ev_error", ["load", e, r, a])
        })
    }, t.su.Store.prototype.update = function(e, r, a, n, o) {
        var i = this.keyProperty;
        if (e != undefined && null != e) {
            var s = this.getIndex(e),
                d = {},
                u = this;
            d[i] = e, this.proxy.write(t.extend({
                operation: "update",
                index: s
            }, d, r), function(r, n, o, i) {
                t.isArray(r) || (r = [r]), t.extend(r, d), r = u.dataFormat(r), "operation" == u.updateMode ? u.updateData(e, r, function(t, e) {
                    a && a.call(u, t, e)
                }) : "complete" == u.updateMode ? u.loadData(r, n, !1, function(t) {
                    a && a.call(u, t)
                }) : u.load({}, function(t, e, r, n) {
                    a && a.call(u, t, e, r, n)
                }), t(u).trigger("ev_update", [u, r])
            }, function(e, r) {
                n && n.call(u, e, r), t(u).trigger("ev_failed", ["update", e, r])
            }, function(e, r, a) {
                o && o.call(u, e, r, a), t(u).trigger("ev_error", ["update", e, r, a])
            })
        }
    }, t.su.Store.prototype.updateColumns = function(e, r, a, n, o) {
        var i = this;
        r = r || {};
        this.proxy.read(t.extend({
            operation: "updateColumn",
            columns: e
        }, r), function(r, n, o, s) {
            for (var d = 0; d < i.data.length; d++)
                for (var u = 0; u < r.length; u++)
                    if (i.data[d].key == r[u].key)
                        for (var l = 0; l < e.length; l++) i.data[d][e[l]] = r[u][e[l]];
            for (d = 0; d < i.snapshot.length; d++)
                for (u = 0; u < r.length; u++)
                    if (i.snapshot[d].key == r[u].key)
                        for (l = 0; l < e.length; l++) i.snapshot[d][e[l]] = r[u][e[l]];
            a && a.call(i, r, n, o, s), t(i).trigger("ev_updatecolumns", [e, r])
        }, function(e, r) {
            n && n.call(i, e, r), t(i).trigger("ev_failed", ["updatecolumns", e, r])
        }, function(e, r, a) {
            o && o.call(i, e, r, a), t(i).trigger("ev_error", ["updatecolumns", e, r, a])
        })
    }, t.su.Store.prototype.remove = function(e, r, a, n, o) {
        var i = this,
            s = this.keyProperty;
        t.isArray(e) || (e = [e]);
        var d = this.getIndexs(e);
        this.proxy.write(t.extend({
            operation: "remove",
            key: e,
            index: d
        }, r), function(t, e, r, n) {
            if ("operation" == i.removeMode) {
                if (t.length > 0)
                    if (t[0][s]) {
                        for (var o = [], d = 0, u = t.length; d < u; d++)
                            if (t[d].success) {
                                var l = t[d][s];
                                o.push(l)
                            } i.removeDataByKey(o)
                    } else {
                        var p = [],
                            c = 0;
                        for (u = t.length; c < u; c++)
                            if (t[c].success) {
                                d = t[c]["index"];
                                p.push(parseInt(d, 10))
                            } i.removeDataByIndex(p)
                    } a && a.call(i, o, p, t)
            } else "complete" == i.removeMode ? (t = i.dataFormat(t), i.loadData(t, e, !1, function(t) {
                a && a.call(i, t, e)
            })) : i.load({}, function(t, e, r, n) {
                a && a.call(i, t, e, r, n)
            })
        }, function(e, r) {
            n && n.call(i, e, r), t(i).trigger("ev_failed", ["remove", e, r])
        }, function(e, r, a) {
            o && o.call(i, e, r, a), t(i).trigger("ev_error", ["remove", e, r, a])
        })
    }, t.su.Store.prototype.dataFormat = function(e) {
        var r = this.fields,
            a = this.keyProperty;
        t.su.format;
        e && !t.isEmptyObject(e) || (e = []), t.isArray(e) || (e = [e]);
        for (var n = [], o = !1, i = 0; i < r.length; i++) {
            for (var s = r[i].name, d = (r[i].type, r[i].mapping || s), u = r[i].defaultValue || undefined, l = r[i].dataFormat ? r[i].dataFormat : function(t) {
                    return t
                }, p = 0; p < e.length; p++) {
                n[p] = n[p] || {};
                var c = e[p][d],
                    h = l(c === undefined || null === c ? u : c);
                n[p][s] = h
            }
            a == name && (o = !0)
        }
        if (!o)
            for (p = 0; p < e.length; p++) {
                n[p] = n[p] || {};
                var y = e[p][a];
                n[p][a] = y === undefined || null === y ? "key-" + (p + this.keyLength) : y
            }
        return this.keyLength += e.length, n
    }, t.su.Store.prototype.insertData = function(e, r, a) {
        var n = this.data;
        if (e > n.length) return !1;
        t.isArray(r) || (r = [r]);
        var o = n.slice(0, e),
            i = n.slice(e, n.length),
            s = o.concat(r, i);
        return this.data = null, delete this.data, this.data = s, this.snapshot = null, delete this.snapshot, this.snapshot = t.su.clone(this.data), a && a.call(this, e, r), t(this).trigger("ev_insertdata", [e, r]), t(this).trigger("ev_datachanged", [this, this.data, "insertData"]), this
    }, t.su.Store.prototype.loadData = function(e, r, a, n) {
        return !a && this.data.length > 0 && this.removeAllData(), e && !t.isEmptyObject(e) || (e = []), t.isArray(e) || (e = [e]), this.data = this.data || [], this.data = this.data.concat(e), this.snapshot = null, delete this.snapshot, this.snapshot = t.su.clone(this.data), n && n.call(this, e, a), t(this).trigger("ev_loaddata", [this.data, r]), t(this).trigger("ev_datachanged", [this, this.data, "loadData"]), this
    }, t.su.Store.prototype.updateData = function(e, r, a) {
        r && !t.isEmptyObject(r) || (r = []), t.isArray(r) && (r = r[0]);
        var n = this.getIndex(e);
        if (n !== undefined && null !== n) return this.data.splice(n, 1, r), this.snapshot = null, delete this.snapshot, this.snapshot = t.su.clone(this.data), a && a.call(this, e, r), t(this).trigger("ev_updatedata", [e, n, r]), t(this).trigger("ev_datachanged", [this, this.data, "updateData"]), this
    }, t.su.Store.prototype.removeDataByKey = function(e, r) {
        var a = this.keyProperty;
        t.isArray(e) || (e = [e]);
        for (var n = {}, o = 0, i = e.length; o < i; o++) n[e[o]] = !0;
        var s = this.data,
            d = [];
        for (o = 0, i = s.length; o < i; o++) s[o][a] in n && d.push(o);
        this.removeDataByIndex(d, function(t, e) {
            r && r.call(this, t, e)
        })
    }, t.su.Store.prototype.removeDataByIndex = function(e, r) {
        var a = this.keyProperty,
            n = this.data;
        t.isArray(e) || (e = [e]), e.sort(function(t, e) {
            return t - e
        });
        for (var o = [], i = e.length - 1; i >= 0; i--) {
            var s = e[i];
            isNaN(s) || (o.push(n[s][a]), n.splice(e[i], 1))
        }
        return this.snapshot = null, delete this.snapshot, this.snapshot = t.su.clone(this.data), r && r.call(this, o, e), t(this).trigger("ev_removedata", [o, e]), t(this).trigger("ev_datachanged", [this, this.data, "removeData"]), this
    }, t.su.Store.prototype.removeAllData = function(e) {
        return this.data = null, delete this.data, this.data = [], this.snapshot = null, t(this).trigger("ev_removeAllData", [this]), t(this).trigger("ev_datachanged", [this, this.data, "removeData"]), this
    }
}(jQuery),
function(t) {
    t.su.TreeStore = function(e) {
        var r = t.extend({}, {
                proxy: null,
                fields: [{
                    name: "name"
                }, {
                    name: "path"
                }, {
                    name: "hasBranch"
                }, {
                    name: "branches"
                }, {
                    name: "leavesInfo"
                }, {
                    name: "leaves"
                }, {
                    name: "uuid"
                }],
                keyProperty: "path"
            }, e),
            a = new t.su.Store(r);
        return a.getNode = function(t) {
            return this.map && this.map[t] ? this.map[t] : undefined
        }, a.loadNode = function(e, r, a) {
            var n = this,
                o = n.getNode(e);
            if (o) {
                var i = o.path,
                    s = t.extend({
                        operation: "read",
                        path: i
                    }, r);
                n.proxy.read(s, function(r, o, i) {
                    a && a.call(n, r, o, i), (t.isArray(r.branches) || t.isArray(r.leaves)) && (n.map[e].branches = r.branches, t(n).trigger("ev_datachanged", [n, "loadNode"]), t(n).trigger("ev_loadnode", [n, e, r]))
                })
            }
        }, a.updateMap = function() {
            var t = this,
                e = t.data[0];
            if (e) {
                var r = {};
                r[e[t.keyProperty]] = e;
                var n = function(e) {
                    if (e.branches)
                        for (var o = 0, i = e.branches.length; o < i; o++) {
                            var s = e.branches[o];
                            a.mapId++, r[s[t.keyProperty]] = s, n(s)
                        }
                };
                n(e), a.map = r
            }
        }, t(a).on("ev_datachanged", a.updateMap), a
    }
}(jQuery);