#! /usr/bin/python
# coding=utf-8
import gmpy
from Crypto.Util.number import *
from pwn import *

# 利用Euler's Theorem分解n，用在最大質因數很小的時候
def pollard(n):
  a=2
  b=2
  while True:
    a=pow(a, b, n)
    d=gmpy.gcd(n, a-1)
    if d>1:
      return d
    b+=1

# 題目給的
c=8311079286609423701890874465014328453297749013000359737280326858543960138449603267296832634042902025602998716205926624689765580447565198576846087293231441674624733920141276389804635140071488888353509987107408382844738543759539104750775004381510154709106362643233960915600852715753266271209747133665584282
n=10180182857744768743275805436494081662461643239031634545835141648631361641809830292042662824026139174866394166530365537796574788389769365997679190963576667309754711464554738736542126193301779993218531314379610731038190175789414312196171100460107186281710578944183898009401285893421749443449310513075031027
e=65537

# 把n分解完
primes=[]
while not isPrime(n):
  a=pollard(n)
  primes.append(a)
  n/=a
primes.append(n)
'''
primes=[
  2422338001,
  3409596103,
  4196132201,
  3666642919,
  3607018949,
  3524523071,
  2950464061,
  3123721871,
  2834067877,
  2750875661,
  2568458483,
  3190149577,
  3292141577,
  3593054561,
  2749640251,
  4168090769,
  4230852491,
  2604755971,
  3690897437,
  3672308491,
  4075164839,
  2499284551,
  2494723087,
  2853235013,
  4068037063,
  3634322333,
  3007853063,
  3090005209,
  2630222809,
  2405365637,
  2708341477,
  3096566531
]
'''

# 算出d後解密
phi=1
for i in primes:
  phi*=(i-1)
d=inverse(e, phi)
plain=pow(c, d, n)
plain_hex=hex(plain)[2:]
print unhex(plain_hex)